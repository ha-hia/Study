
## 三次握手
`TCP(Transmission Control Protocol, 传输控制协议)`：是一种面向连接、可靠、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后需要断开连接。

客户端使用connect（）函数与服务端建立连接，确保IP地址、端口以及物理链路等的正常，为数据传输提供通道。建立TCP连接的过程中，将在客户端和服务端之间传输三个数据包，俗称 **三次握手**。


* 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。

* 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。

* 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：建立一个新连接。
FIN：断开一个连接。

``` plantuml
@startuml
客户端 -> 服务端 : Step1：SYN (Seq=1000)
客户端 --> SYN_SEND 
客户端 <- 服务端 : Step2：SYN(Seq=2000) + ACK=1001
服务端 --> SYN_RECV
客户端 -> 服务端: Step3：ACK=2001
客户端 --> ESTABLISED
服务端 --> ESTABLISED
@enduml
```

### 步骤拆分
0. 客户端调用`socket()`创建套接字后，还没有建立连接，套接字处于`CLOSED`状态；服务器调用`listen()`后，套接字进入`LISTEN`状态，开始监听客户端请求。
1. 客户端调用`connect()`后，TCP协议组建一个数据包，设置SYN标志位，表示该数据包是用来与服务器建立同步连接。同时生成一个随机数，填充`Seq`字段，表示该数据包的序号。填充完毕后，向服务器发送该数据包，客户端进入`SYN_SENT`状态。
2. 服务器收到数据包，检测到设置了`SYN`标志位，知道这是客户端发送过来进行建立连接的“请求包”。服务端将组建一个数据包，设置`SYN`和`ACK`标志位，该`SYN`表示该数据报用来建立连接，`ACK`用来确认收到了刚才客户端发送的数据包。
服务端生成一个随机数，填充`Seq`字段；将客户端数据包序列号(1000)加 1 来填充 确认号`Ack`，服务器将数据包发出进入`SYN-RECV`状态。
3. 客户端收到数据包，检测到设置了`SYN`和`ACK`标志位,知道这是服务端发送的“确认包”。客户端检测`Ack`字段值是否为其序列号加1，如果是则连接建立成功。
客户端将组建第三个数据包，设置`Ack`确认号值为服务器发送数据序列号加1，表示客户端正确接收了服务器发来的“确认包”，客户端发送数据包后进入`ESTABLISED`状态，表示成功建立连接
4. 服务器接收到数据包，检测到`ACK`标志位且`Ack`值为服务器发送数据序列号加1，表明建立连接成功，服务器进入`ESTABLISED`状态
5. 客户端和服务端都建立连接成功

三次握手的关键是确认对方收到了自己的数据包，通过确认号“Ack”来实现。计算机会记录下自己发送的数据包序号Seq，待收到对方数据后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。


C : Established
S : Established
C -right-> S : FIN Seq=5000
C --> FIN_WAIT_1
S --> CLOSED_WAIT
S -right-> C : FIN Seq=5000

客户端-> 服务端 : Step1：SYN (Seq=1000)
客户端 --> SYN_SEND 
客户端 <- 服务端 : Step2：SYN(Seq=2000) + ACK=1001
服务端 --> SYN_RECV
客户端 -> 服务端: Step3：ACK=2001
客户端 --> ESTABLISED
服务端 --> ESTABLISED
## 四次挥手
``` plantuml
@startuml
客户端 -> 服务端 : FIN (Seq = 5000)
客户端 --> FIN_WAIT_1
服务端 -> 客户端 : ACK (Seq = 7000 Ack = 5001)
服务端 --> CLOSED_WAIT
客户端 --> FIN_WAIT_2
服务端 -> 客户端 : FIN (Seq = 7001 Ack = 5001)
服务端 --> LAST_ACK
客户端 -> 服务端 : ACK(Seq = 5001 Ack = 7002)
客户端 --> TIME_WAIT
服务端 --> CLOSED
客户端 --> CLOSED
@enduml
```

### 步骤拆分
建立连接后，客户端处于`ESTABLISED`状态,当客户端调用`close()`发起断开连接请求时：
1. 客户端向服务端发送`FIN数据包`，客户端进入`FIN_WAIT_1`状态
2. 服务端收到设置了`FIN标志位`的数据包，知道是断开连接的需求，但服务器不是立马就断开连接，而是先向客户端发送"确认包"，自己需要准备一下才能断开连接。进入`CLOSE_WAIT`状态。
3. 客户端接收到“确认包”后进入`FIN_WAIT_2`状态，等待服务端准备好。
4. 等待片刻后，服务端准备完毕，可以断开连接，则主动向客户端再发送`FIN数据包`,表示可以断开连接了，之后进入`LAST_ACK`状态。
5. 客户端接收到服务器发送的`FIN数据包`，接着再向服务端发送`ACK确认包`，告诉服务器，你断开连接吧，接着进入`TIME_WAIT`状态。
6. 服务器接收到客户端发送的`ACK确认包`，就断开连接，关闭套接字，进入`CLOSED`状态。

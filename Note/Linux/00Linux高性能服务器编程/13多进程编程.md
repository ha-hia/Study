# 第 13 章 多进程编程

将对如下内容进行讨论：

* fork 系统调用(复制进程映像)和 exec 系列系统调用(替换进程映像)
* 僵尸进程和如何避免僵尸进程
* 进程间通信(IPC)最简单方式：管道
* System V 进程间通信方式：信号量、消息队列和共享内存
* 进程间传递文件描述符的通用办法：通过 UNIX 本地域 socket 传递特殊辅助数据



## 1、fork 系统调用

``` C++
#include <sys/types.h>
#include <unistd.h>
/**
	Linux创建新进程
	成功调动将有两次返回，父进程中返回子进程PID，子进程中返回0，用于判断父子进程
	失败 -1，置 errno
*/
pid_t fork(void);
```

fork 函数复制当前进程，在内核中创建一新的进程表项，其中很多属性如：堆指针、栈指针和标志寄存器的值都与原进程相同。因此，子进程代码与父进程完全相同，也会采取“写时复制”的方式复制父进程的数据（堆数据、栈数据和静态数据），但子进程的一些属性：如 PPID 将是原进程的 PID、信号位图被清除即原进程的信号处理函数对新的子进程不起作用。

**写时复制：** 任一进程（父进程或子进程）对数据执行了写操作，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）。所以如果在程序中分配了大量内存，使用 fork 应谨慎使用避免不必要的内存分配和数据复制。

对于在父进程中打开的文件描述符，在子进程中也是打开的，文件描述符的引用计数加 1。父进程的用户根目录、当前工作目录等变量的引用计数均会加 1。



## 2、exec 系统调用

```C++
#include <unistd.h>
extern char** environ;

/**
	替换当前进程映像，执行其他程序
	path:指定可执行文件的完整路径
	file:接收文件名，具体位置在环境变量 PATH 中搜寻
	arg:可变参数，被传递给新程序的main函数
	argv:参数数组，被传递给新程序的main函数
	envp:设置新程序的环境变量，如果未设置，则使用全局变量environ指定的环境
	
	失败 -1，置errno
	成功则一般不返回，直接执行新程序去了，原程序exec调用后的代码不再执行，被exec参数指定的程序完全替换
	exec 函数不会关闭原程序打开的文件描述符，除非该文件描述符设置了 SOCK_CLOEXEC 类似的属性
*/
int execl(const char* path, const char* arg, ...);
int execlp(const char* file, const char* arg, ...);
int execle(const char* path, const char* arg, ..., char* const envp[]);
int execv(const char* path, char* const argv[]);
int execl(const char* file, char* const argv[]);
int execl(const char* path, char* const argv[], char* const envp[]);
```



## 3、处理僵尸进程

多进程程序中，父进程将会对子进程的退出状态进行跟踪。因此，子进程结束后内核不会立马释放掉该进程的进程表表项，以满足父进程后续对子进程退出信息的查询。

**子进程僵尸态：**

1. 子进程结束运行之后，父进程读取其退出状态之前
2. 父进程结束或异常退出，而子进程继续运行。此时子进程的 PPID 将被操作系统设置为 1，即 init 进程接管该子进程，并等待它结束。

父进程没有正确处理子进程的返回信息，子进程都将停留在僵尸态，占据内核资源。所以为了避免僵尸进程的产生，需要在父进程中等待子进程的结束并获取子进程的返回信息。

```C++
#include <sys/types.h>
#include <sys/wait.h>

/**
描述：
	阻塞进程，直到该进程的某个子进程结束运行
返回：
	返回子进程的 PID ，将子进程退出状态信息存储于stat_loc参数指向的内存
*/
pid_t wait(int* stat_loc);

/**
描述：
	等待pid参数指定的子进程；pid = -1 时与wait相同，等待任意一个子进程结束
	stat_loc：存储子进程退出状态信息的内存
	options：控制waitpid行为。为WNOHANG时，waitpid将是非阻塞的
返回：
	pid指定的目标子进程没有结束或意外终止，返回0
	子进程正常退出，返回子进程PID
	失败 -1，置 errno
*/
pid_t waitpid(pid_t pid, int* stat_loc, int options);
```

sys/wait.h 头文件中用于解释子进程退出状态信息的宏：

|          宏           |                      含义                       |
| :-------------------: | :---------------------------------------------: |
|  WIFEXITED(stat_val)  |          如果子进程正常结束，返回非0值          |
| WEXITSTATUS(stat_val) |      如果WIFEXITED非0，返回子进程的退出码       |
| WIFSIGNALED(stat_val) | 如果子进程因为一个未捕获的信号而终止，返回非0值 |
|  WTERMSIG(stat_val)   |       如果WIFSIGNALED非0，返回一个信号值        |
| WIFSTOPPED(stat_val)  |          如果子进程意外终止，返回非0值          |
|  WSTOPSIG(stat_val)   |        如果WIFSTOPPED非0，返回一个信号值        |

**利用 SIGCHLD 信号高效使用：** 当子进程退出后，将给父进程发送一个 SIGCHLD 信号，这使得我们可以在“事件已发生的情况下，执行非阻塞调用提高程序效率”；即在该信号的信号处理函数内非阻塞的使用 waitpid 系统调用。



## 4、管道

### 无名管道 pipe

管道能在父、子进程间传递数据，因为 fork 调用之后两个管道文件描述符都保持打开。使用 pipe 只能保证父、子进程间一个方向的数据传输，如果需要双向数据传输，则需要使用两个管道或使用 socketpair 系统调用创建全双工管道。

缺点：无名管道只能在父、子进程间创建通信，而无关联的进程则不行。



### 命名管道 FIFO

可以在无关联的进程间建立通信管道。



## 5、System V IPC（进程间通信）

**进程同步引入背景：** 多进程同时访问系统某一个资源，如：同时写一个数据库的某条记录或同时修改某文件，需要考虑进程的同步问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。

**临界区：** 对共享资源进行访问的很短的一段代码，关键代码段。



### 5.1 信号量

**概念：** 一种特殊的变量，只能取自然数值并只支持 P（进入临界区）和 V（退出临界区）两种操作。

![](./Pic/13-2.png)

假设信号量 SV（一般取二进制信号量0/1），执行P、V操作含义如下：

* P（SV）：如果 SV 的值大于0，则减 1；如果 SV 的值等于0，则挂起进程的执行
* V（SV）：如果有其他进程因为等待 SV 而挂起，则唤醒；如果没有，将 SV 加1。

如图：

* 信号量 SV 的值为1，临界区（关键代码段）可用，如果此时进程 A 执行P（SV），则 A 进入临界区，SV 为 0。
* 当进程 B 想进入临界区时，发现 SV 为 0，则被挂起。
*   进程 A 离开临界区，执行 V（SV），SV 为 1，临界区重新可用，处于挂起状态的进程 B 被唤醒执行 P（SV）进入临界区。
* 如果此时进程 A在执行 P（SV），将被操作系统挂起等待 B 退出临界区。



#### semget、semop 和 semctl 系统调用

```C++
#include <sys/sem.h>

/**
描述：
	创建一个新的信号量集或获取一个已经存在的信号量集
	key：键值，标识全局唯一的信号量集，如文件名全局唯一标识一个文件。通过信号量通信的进程需要使用相同的键值创建/获取该信号量。
	num_sems：信号量集的中信号量的数目。创建信号量时需要指定，如获取已经存在的信号量可以置为0。
	sem_flags：一组标志，低9bit为该信号量的权限。与open参数mode相同
	
返回值：
	成功返回正整数值表示信号量集的标识符;失败-1，置errno
*/
int semget(key_t key, int num_sems, int sem_flags);
```

semget 用于创建信号量集市，与之关联的内核数据结构体 semid_ds 将被创建并初始化

```C++
#include <sys/sem.h>
struct ipc_perm
{
    key_t key;//键值
    uid_t uid;//所有者的有效用户ID
    gid_t gid;//所有者的有效组ID
    uid_t cuid;//创建者的有效用户ID
    gid_t cgid;//创建者的有效用户ID
    mode_t mode;//访问权限
    ...
};

struct semid_ds
{
    struct ipc_perm sem_perm;//信号量的操作权限
    unsigned long int sem_nsems;//该信号量集中的信号量的数目
    time_t sem_otime;//最后一次调用semop的时间
    time_t sem_ctime;//最后一次调用semctl的时间
    ...
};
```

初始化内容包括：

1. 将 sem_perm.cuid 和 sem_perm.uid 设置为调用进程的有效用户ID

2. 将 sem_perm.cgid 和 sem_perm.gid 设置为调用进程的有效组ID

3. 将 sem_perm.mode 最低9位设置为 sem_flags 参数的最低9位

4. 将sem_otime设置为0

5. 将sem_ctime设置为当前系统时间



#### semop 系统调用

```C++
#include <sys/sem.h>
///涉及的一些内核变量
unsigned short semval;//信号量的值
unsigned short semzcnt;//等待信号量变为0的进程数量
unsigned short semncnt;//等待信号量增加的进程数量
pid_t sempid;//最后一次执行semop操作的进程ID

struct sembuf
{
    unsigned short int sem_num;//信号量集中信号量的编号，从0开始
    short int sem_op;//操作类型，可选正整数、0和负整数，操作行为受sem_flg影响
    short int sem_flg;//IPC_NOWAIT:无论信号量操作成功与否，立刻返回
    				  //SEM_UNFO：当进程退出时取消正在进行的semop操作，见下文
};

/**
描述：
	改变信号量的值，即P/V操作
	sem_id：semget返回的信号量集标识符，用以指定被操作的目标信号量集
	semops：指向sembuf结构体的数组指针
	um_sem_ops：指定要执行的操作个数，即semops数组中元素的个数
	
	semop对semops数组中每个成员按照数组顺序依次进行原子操作，避免别的进程在同一时刻按照不同顺序对信号集中的信号量执行操作导致竞态条件
	
返回值：
	成功0；失败 -1，置 errno，失败时semops数组中指定的所有操作不被执行
*/
int semop(int sem_id, struct sembuf* semops, size_t um_sem_ops);
```

**sem_flg 对 sem_op操作类型的影响：**

1. sem_op大于0，则 sem_op 将被操作的信号量的值 semval 增加 sem_op。要求调用进程对被操作信号量集拥有写权限。若设置 SEM_UNDO 标志，系统将更新进程的 semadj 变量（用于跟踪进程对信号量的修改情况）。
2. sem_op等于0，则表示为“等待0”的操作，要求调用进程对被操作信号量集拥有读权限。如果此时信号量的值为0，立即成功返回。如果信号量值不为0，则 semop 失败返回或阻塞进程等待信号量变为0；此时，如果设置 IPC_NOWAIT 标志，则立刻返回错误置 errno 为 EAGAIN;为 IPC_NOWAIT 标志则信号量的 semzcnt 值加1，进程睡眠直到发生以下条件之一：信号量的值semval变为0，此时系统将信号量的semzcnt减1；被操作信号量所在的信号量集被进程移除，此时semop调用返回失败置 errno 为 EIDRM；调用被信号中断，semop调用返回失败置 errno 为 EINTR，同时该信号量的semzcnt减1。
3. sem_op小于0，表示对信号量进行减操作，即期望获得信号量。要求调用进程对被操作信号量集拥有写权限。如果信号量的值 emval 大于或等于em_op的绝对值，则semop操作成功，调用进程立即获得信号量，并且系统将该信号量的semval值减去sem_op的绝对。此时如果设置了SEM_UNDO标志，则系统将更新进程的semadj变量。如果信号量的值semval小于sem_op的绝对值，则semop失败返回或者阻塞进程以等待信号量可用。在这种情况下，当IPC NOWAIT标志被指定时，semop立即返回一个错误，并设置 errno 为EAGAIN。如果未指定IPC_NOWAIT标志，则信号量的semncnt值加1，进程被投入睡眠直到下列3个条件之一发生:信号量的值semval变得大于或等于sem_op的绝对值，此时系统将该信号量的semncnt值减1，并将semval减去sem_op的绝对值，同时，如果SEM_UNDO标志被设置，则系统更新semadj变量;被操作信号量所在的信号量集被进程移除，此时semop调用失败返回，errno被设置为EIDRM;调用被信号中断，此时semop调用失败返回，errno被设置为EINTR，同时系统将该信号量的 semncnt值减1。


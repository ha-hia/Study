# 第 10 章 信号

**定义：** 

* 由用户、进程或系统发送给目标进程的信息；用以通知目标进程某个状态的改变或系统异常。

**产生的条件：**

* 对于前台进程，用户通过输入特殊的终端字符来发送信号。如：Ctrl + C 通常会给进程发送一个中断信号。
* 系统异常。如：非法的内存访问
* 系统状态变化。如：alarm 定时器到期将引起 SIGALRM 信号
* 运行 kill 命令或调用 kill 函数

服务器为了避免异常终止，必须处理或至少忽略一些常用的信号。

将对如何发送信号、处理信号和 Linux 支持的信号种类进行讨论。



# 1、Linux 信号概述

### 发送信号

Linux 下，一个进程给其他进程发送信号的 API 是 kill 函数

```C++
#include <sys/types.h>
#include <signal.h>

/**
描述：
	将信号sig发送给目标进程pid
	pid > 0, 信号发送给PID为pid的进程
	pid = 0, 信号发送给本进程组内的其他进程
	pid = -1,信号发送给除init进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限 
	pid < -1,信号发送给组ID为-pid的进程组中的所有成员

返回：
	成功 0，失败 -1 置errno
		EINVAL：无效的信号
		EPERM：该进程没有权限发送信号给任何一个目标进程
		ESRCH：目标进程或进程组不存在
*/
int kill(pid_t pid, int sig);

/**
	Linux定义的信号值都大于0；取sig =0,则kill函数将不发送任何信号，但可以用来检测目标进程或进程组是否存在，因为检查工作总是在发送之前执行，不过由于进程PID的回绕且不是原子操作，可能得到的不一定是期望的进程PID
*/
```



### 信号处理方式

目标进程接收到信号时，需要定义一个接收函数来处理：

```C++
#include <signal.h>
/**
	带有的一个整形参数是用来指示信号类型
	为避免竞态条件，信号处理函数需要是可重入的，所以内部严禁调用不安全的函数
*/
typedef void(*__sighandler_t)(int);

//系统提供的两种处理方式
#include <bitd/signum.h>
//忽略目标信号
#define SIG_IGN ((__sighandler_t) 1)
//按默认方式处理信号：结束进程(Term)、忽略信号(Ign)
//结束进程并生成核心转储文件(Core)、暂停进程(Stop)、继续进程(Cont)
#define SIG_DFL ((__sighandler_t) 0)

```

和网络编程关系紧密的信号：SIGHUP、SIGPIPE、SIGURG



### 中断系统调用

Linux 独有，程序在执行处于阻塞状态的系统调用时接收到信号，且该信号有设置信号处理函数，则默认情况下系统调用将被中断，errno 置为 EINTR。可以使用 sigaction 函数为信号设置 SA_RESTART 标志以自动重启被该信号中断的系统调用。

默认行为是暂停进程的信号（SIGSTOP、SIGTTIN），如果没有为其设置信号处理函数，也可以中断某些系统调用(如：connect、epoll_wait)
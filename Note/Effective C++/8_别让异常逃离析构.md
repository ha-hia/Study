## 条款8：别让异常从析构函数逃离
当程序发生异常时，我们往往会停止当前的工作并跳出当前程序去处理异常；但当异常发生在析构函数，由于析构函数的性质(回收当前对象所占用的资源)，如果将异常传播至析构函数之外，将产生麻烦。

**方法1：**  
一旦发生异常就调用`std::abort`强迫程序结束，阻止异常从析构函数传播出去。

**方法2：**  
“吞掉”异常，不跳出析构函数转到异常处理函数处理，忽略了异常的处理。  
此方案必须保证程序在遭遇并忽略一个错误之后能够继续可靠地执行。

**方法3：**
优化接口设计，赋予客户机会操作，因此可让客户对该操作的异常进行处理。

### 结论：
* 如果析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，结束程序或吞下不让其传播到析构函数以外。
* 如客户需要对某个操作在运行期间抛出的异常做出反应，应提供一普通函数（而非在析构函数）执行该操作。

## 条款9：绝不在构造和析构函数中调用虚函数
* 子类实例化对象时，子类中的基类成分会在子类成分构造之前先被构造。  
* 基类构造期间，虚函数不会下降到子类的层次（此时子类的成员变量是没有初始化的），被调用的虚函数是基类版本。  
* 析构函数调用虚函数，一旦子类析构函数开始执行，对象内的子类成员变量便呈现未定义值，进入基类析构函数后对象成为一个基类对象。  

**不只是虚函数会被编译器解析至基类，运行期类型信息如：dynamic_cast/typepid也是这样**

